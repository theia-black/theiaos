<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TheiaOS Control</title>
    <meta name="color-scheme" content="dark light" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      #bg-canvas, #particle-canvas {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
      }
      #bg-canvas { z-index: 0; }
      #particle-canvas { z-index: 1; }
      .film-grain {
        position: fixed; top: -50%; left: -50%; width: 200%; height: 200%;
        z-index: 2; pointer-events: none; opacity: 0.03;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        animation: grain 0.5s steps(1) infinite;
      }
      @keyframes grain {
        0% { transform: translate(0,0); }
        25% { transform: translate(-5%,-5%); }
        50% { transform: translate(5%,3%); }
        75% { transform: translate(-3%,5%); }
        100% { transform: translate(3%,-3%); }
      }
      theiaos-app { position: relative; z-index: 3; }
    </style>
  </head>
  <body>
    <canvas id="bg-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <div class="film-grain"></div>
    <theiaos-app></theiaos-app>
    <script type="module" src="/src/main.ts"></script>
    <script>
    (function initBackground() {
      const canvas = document.getElementById("bg-canvas");
      if (!canvas || typeof THREE === "undefined") return;
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
      let mouseX = 0.5, mouseY = 0.5;
      document.addEventListener("mousemove", e => {
        mouseX = e.clientX / window.innerWidth;
        mouseY = 1.0 - e.clientY / window.innerHeight;
      });
      const fragmentShader = `
        precision highp float;
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123); }
        float vnoise(vec2 p) {
          vec2 i = floor(p); vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x), mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
        }
        float fbm(vec2 p) {
          float v = 0.0, a = 0.5; mat2 m = mat2(0.866, 0.5, -0.5, 0.866);
          for (int i = 0; i < 6; i++) { v += a * vnoise(p); p = m * p * 2.02; a *= 0.49; }
          return v;
        }
        void main() {
          vec2 uv = gl_FragCoord.xy / u_resolution;
          float aspect = u_resolution.x / u_resolution.y;
          vec2 p = (uv - 0.5) * vec2(aspect, 1.0);
          vec2 gCenter = vec2(0.0, -0.2);
          float breathe = 1.0 + 0.005 * sin(u_time * 0.41888);
          vec2 toC = p - gCenter; float dist = length(toC);
          vec2 dir = toC / (dist + 0.001);
          float lensStr = 0.12 * breathe / (dist * dist + 0.04);
          vec2 lensed = p - dir * lensStr;
          vec2 mWorld = (u_mouse - 0.5) * vec2(aspect, 1.0);
          vec2 toM = lensed - mWorld; float mDist = length(toM);
          lensed -= (toM / (mDist + 0.001)) * 0.015 / (mDist * mDist + 0.1);
          vec3 color = vec3(0.014, 0.014, 0.02);
          vec2 vUV = lensed * 2.5;
          float w1 = fbm(vUV + u_time * 0.01); float w2 = fbm(vUV + vec2(5.2, 1.3) + u_time * 0.008);
          float veins = fbm(vUV + vec2(w1, w2) * 0.8);
          color += vec3(0.025, 0.006, 0.018) * smoothstep(0.012, 0.0, abs(veins - 0.5)) * 0.35;
          color += vec3(0.008, 0.004, 0.025) * smoothstep(0.015, 0.0, abs(w1 - 0.48)) * 0.25;
          vec2 dPos = lensed - gCenter; vec2 dFlat = dPos * vec2(1.0, 3.2);
          float dR = length(dFlat); float dAngle = atan(dFlat.y, dFlat.x) + u_time * 0.07;
          float ring = smoothstep(0.06, 0.1, dR) * smoothstep(0.38, 0.26, dR);
          vec2 dUV = vec2(dAngle * 1.8, dR * 10.0);
          float dn1 = fbm(dUV + u_time * 0.035); float dn2 = fbm(dUV * 1.3 + vec2(2.7, 0.0) - u_time * 0.02);
          float dn3 = fbm(vec2(dAngle * 0.5, dR * 20.0) + u_time * 0.015);
          vec3 diskCol = vec3(0.12, 0.018, 0.028) * dn1 + vec3(0.015, 0.01, 0.055) * dn2 + vec3(0.09, 0.045, 0.008) * dn3 * smoothstep(0.2, 0.08, dR);
          diskCol *= 0.6 + 0.4 * dn1;
          color += diskCol * ring;
          color += vec3(0.03, 0.008, 0.012) * (0.02 / (dR + 0.02)) * 0.3;
          float hb = pow(max(0.0, sin(u_time * 4.189)), 30.0);
          color += vec3(0.035, 0.008, 0.014) * hb / (1.0 + dist * dist * 15.0) * 0.6;
          color *= 1.0 - smoothstep(0.1, 0.85, length(uv - 0.5));
          color = pow(max(color, vec3(0.0)), vec3(1.0 / 2.2));
          color += (hash(gl_FragCoord.xy + fract(u_time * 100.0)) - 0.5) / 255.0;
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      const material = new THREE.ShaderMaterial({
        uniforms: { u_time: { value: 0 }, u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, u_mouse: { value: new THREE.Vector2(0.5, 0.5) } },
        vertexShader: "void main() { gl_Position = vec4(position, 1.0); }",
        fragmentShader
      });
      scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));
      window.addEventListener("resize", () => { renderer.setSize(window.innerWidth, window.innerHeight); material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight); });
      const t0 = performance.now();
      (function animate() { material.uniforms.u_time.value = (performance.now() - t0) * 0.001; material.uniforms.u_mouse.value.set(mouseX, mouseY); renderer.render(scene, camera); requestAnimationFrame(animate); })();
    })();
    (function initParticles() {
      const canvas = document.getElementById("particle-canvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d"); const COUNT = 800; let W, H; const particles = [];
      function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
      resize(); window.addEventListener("resize", resize);
      function cx() { return W * 0.5; } function cy() { return H * 0.7; }
      for (let i = 0; i < COUNT; i++) {
        const angle = Math.random() * Math.PI * 2, r = 0.15 + Math.random() * 0.85, maxDim = Math.max(W, H);
        particles.push({ x: cx() + Math.cos(angle) * r * maxDim * 0.6, y: cy() + Math.sin(angle) * r * maxDim * 0.6, orbiting: Math.random() < 0.3, speed: 0.08 + Math.random() * 0.2, size: 0.3 + Math.random() * 0.7, alpha: 0.04 + Math.random() * 0.1, hue: Math.random() < 0.5 ? Math.random() * 10 : 220 + Math.random() * 30, sat: 20 + Math.random() * 40, phase: Math.random() * Math.PI * 2 });
      }
      (function draw() {
        ctx.clearRect(0, 0, W, H); const gcx = cx(), gcy = cy(), t = performance.now() * 0.001;
        for (const p of particles) {
          const dx = gcx - p.x, dy = gcy - p.y, dist = Math.sqrt(dx*dx+dy*dy) || 1, nx = dx/dist, ny = dy/dist;
          if (p.orbiting) { p.x += (-ny * p.speed * 0.4 + nx * 0.03) * 0.6; p.y += (nx * p.speed * 0.4 + ny * 0.03) * 0.6; }
          else { p.x += nx * p.speed * 0.25; p.y += ny * p.speed * 0.25; }
          if (dist < 15) { const a = Math.random() * Math.PI * 2; p.x = gcx + Math.cos(a) * Math.max(W,H) * 0.55; p.y = gcy + Math.sin(a) * Math.max(W,H) * 0.55; }
          if (p.x < -20 || p.x > W+20 || p.y < -20 || p.y > H+20) { const a = Math.random() * Math.PI * 2; p.x = gcx + Math.cos(a) * Math.max(W,H) * 0.5; p.y = gcy + Math.sin(a) * Math.max(W,H) * 0.5; }
          ctx.globalAlpha = p.alpha * (0.7 + Math.sin(t * 0.8 + p.phase) * 0.3);
          ctx.fillStyle = "hsl(" + p.hue + ", " + p.sat + "%, 55%)";
          ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
        }
        requestAnimationFrame(draw);
      })();
    })();
    </script>
  </body>
</html>
